To do util/hash.go:
- change "Payload" to "RawPayload"
- add endpoint field to RawPayload struct
- change "result" to pingBody
- change "Hash" to "TransformAndFormat"





To do internal/server/routes.go:
- change "Payload" to "RawPayload"
- change function name to "VendorPingHandler"
- remove http method restriction
- change
//OLD
var payload util.Payload
err := json.NewDecoder(r.Body).Decode(&payload)

//NEW
// Create a JSON decoder
decoder := json.NewDecoder(r.Body)
  // Create a payload variable and load JSON into it
var payload util.Payload
err := decoder.Decode(&payload)

- if RawPayload.Endpoint == nil, return error to SF
- change JSON response to successful Hopp response
- either make request, or pass headers, method, and payload to MakeRequest() in another file


To do util/request.go:
- copy headers, method, and JSON from hashed payload, and make http request to buyer


To do util:
- create decode.go and DecodePayload()
- create init.go and Initializer()
- create ping.go and Ping()

func Ping(r *http.Request, e string, p map[string]interface{}) {
req, err := http.NewRequest(r.Method, e, p)
if err != nil {
log.Fatalf("error sending ping. Err: %v", err)
}

// Copy headers from the original request
    for key, values := range r.Header {
        for _, value := range values {
            req.Header.Add(key, value)
        }
    }

    // Use the request as needed, e.g., send it with an HTTP client
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        log.Fatalf("error sending ping: %v", err)
    }
    defer resp.Body.Close()

    // Handle the response if needed
    log.Printf("Ping response status: %s", resp.Status)
}





Todo server2:
- build response relay to SF
- build secondary server to accept requests
- should be able to accept json in the format we want (already structured), and send response (bid + ping id?)
